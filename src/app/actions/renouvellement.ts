"use server";

import { auth } from "@/auth";
import { db } from "@/db";
import { assujettis, declarations, lignesDeclaration, notesTaxation } from "@/db/schema";
import { eq, desc, and } from "drizzle-orm";
import { revalidatePath } from "next/cache";

/**
 * Validates and processes a quick renewal (reconduction à l'identique).
 * This will duplicate the last declaration and generate a new brouillon Note.
 */
export async function processFastRenewal(): Promise<{ success: boolean; error?: string }> {
    try {
        const session = await auth();
        if (!session?.user?.id) return { success: false, error: "Non autorisé" };

        const [assujetti] = await db
            .select()
            .from(assujettis)
            .where(eq(assujettis.userId, session.user.id))
            .limit(1);

        if (!assujetti) return { success: false, error: "Assujetti introuvable" };

        const currentYear = new Date().getFullYear();

        // Check if already renewed for this year
        const [existingNote] = await db
            .select()
            .from(notesTaxation)
            .where(
                and(
                    eq(notesTaxation.assujettiId, assujetti.id),
                    eq(notesTaxation.exercice, currentYear)
                )
            )
            .limit(1);

        if (existingNote) {
            return { success: false, error: "Une note existe déjà pour l'exercice en cours." };
        }

        // Find last year's declaration
        const [lastDeclaration] = await db
            .select()
            .from(declarations)
            .where(eq(declarations.assujettiId, assujetti.id))
            .orderBy(desc(declarations.exercice))
            .limit(1);

        if (!lastDeclaration) {
            return { success: false, error: "Aucune déclaration précédente trouvée pour le renouvellement." };
        }

        const result = await db.transaction(async (tx) => {
            // 1. Duplicate declaration
            const [newDecl] = await tx.insert(declarations).values({
                assujettiId: assujetti.id,
                exercice: currentYear,
                dateDeclaration: new Date().toISOString(),
                statut: "validee", // Auto-validate exact reconductions
                totalAppareils: lastDeclaration.totalAppareils,
            }).returning();

            // 2. Duplicate lines
            const oldLines = await tx.select().from(lignesDeclaration).where(eq(lignesDeclaration.declarationId, lastDeclaration.id));

            if (oldLines.length > 0) {
                const newLines = oldLines.map(line => ({
                    ...line,
                    id: undefined, // Let DB generate new UUID
                    declarationId: newDecl.id,
                }));
                await tx.insert(lignesDeclaration).values(newLines);
            }

            // 3. Keep Assujetti's latest declaration ID up to date
            await tx.update(assujettis)
                .set({ derniereDeclarationId: newDecl.id })
                .where(eq(assujettis.id, assujetti.id));

            // Note: The actual Note de Taxation will be generated by the background Worker / Agent
            // or we could generate a Brouillon directly here. For now, we simulate the agent picking it up
            // by just leaving the declaration ready. Or we can generate a basic Note.

            // To ensure the flow works immediately, we generate a Brouillon Note
            const [oldNote] = await tx.select().from(notesTaxation).where(eq(notesTaxation.declarationId, lastDeclaration.id)).limit(1);

            if (oldNote) {
                await tx.insert(notesTaxation).values({
                    assujettiId: assujetti.id,
                    declarationId: newDecl.id,
                    exercice: currentYear,
                    montantBrut: oldNote.montantBrut,
                    montantNet: oldNote.montantNet,
                    montantTotalDu: oldNote.montantTotalDu, // Exact same as last year
                    statut: "brouillon", // Will be emitted later
                });
            }

            return { success: true };
        });

        revalidatePath("/assujetti/dashboard");
        revalidatePath("/assujetti/profil/appareils");

        return result;

    } catch (error: any) {
        console.error("Renewal Error:", error);
        return { success: false, error: error.message || "Erreur interne" };
    }
}
